[TOC]

[原文](https://blog.csdn.net/qq_46153765/article/details/113092445?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162612980216780262529357%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162612980216780262529357&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-3-113092445.pc_search_result_cache&utm_term=JVM&spm=1018.2226.3001.4187)

# 初识JVM规范

## 从三种角度认识JVM

![20210124162416689](/Users/zhichaozhang/Study/Java/note/JVM/20210124162416689.png)

### JVM概述

- JVM：Java Virtual Machine，也就是Java虚拟机
- 所谓虚拟机是指：通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的计算机系统
- JVM是通过软件来模拟Java字节码的指令集，是Java程序的运行环境

### JVM主要功能

- 通过 ClassLoader 寻找和装载 class 文件
- 解释字节码成为指令并执行，提供 class 文件的运行环境
- 进行运行期间的内存分配和垃圾回收
- 提供与硬件交互的平台

### 虚拟机是Java平台无关的保障

![20210124162447373](/Users/zhichaozhang/Study/Java/note/JVM/20210124162447373.png)

## JVM规范作用及其核心

### JVM规范作用

- Java 虚拟机规范为不同的硬件提供了一种编译Java技术代码的规范
- 该规范使Java软件独立于平台，因为编译时针对作为虚拟机的“一般机器”而做
- 这个“一般机器”可用软件模拟并运行于各种现存的计算机系统，也可用硬件来实现

### JVM规范定义的主要内容

- 字节码指令集
- Class文件的格式
- 数据类型和值
- 运行时数据区
- 栈帧
- 特殊方法
- 类库
- 异常
- 虚拟机的启动、加载、链接和初始化
- …

## Class字节码解析

### Class文件格式概述

- Class文件是JVM的输入，Java虚拟机规范中定义了Class文件的结构，Class文件是JVM实现平台无关、技术无关的基础
  1. Class文件是一组以8字节为单位的字节流，各个数据项目按序紧凑排列
  2. 对于占用空间大于8字节的数据项，按照高位在前的方式分割成多个8字节进行存储
  3. Class文件格式里面只有两种类型：无符号数、表
     - 无符号数：基本数据类型，以u1、u2、u4、u8来代表几个字节的无符号数
     - 表：由多个无符号和其他表构成的符合数据类型，通常以 "_info"结尾
       

### Class文件的格式

- javap工具生成非正式的 ”虚拟机汇编语言“，格式如下：[[]…]] [comment]
- 是指令操作码在数组中的下标，该数组以字节形式来存储当前方法的Java虚拟机代码；也可以是相当于方法起始处的字节偏移量
- 是指令的助记码、是操作数、是行尾的注释

### Class文件格式说明

- constant_pool_count：是从1开始的
- 不同的常量类型，用tag来区分，它后面对应的 info 结构是不一样的
- L表示对象，[ 表示数组、V表示void
- stack：方法执行时，操作栈的深度
- Locals：局部变量所需的储存空间，单位是slot
- slot是虚拟机为局部变量分配内存所使用的最小单位
- args_size：参数个数，为1的话，因实例方法默认会传入this，locals也会预留一个slot来存放

## ASM

[参考](https://www.jianshu.com/p/a85e8f83fa14)

### ASM概述

- ASM是一个Java字节码操纵框架，它能被用来动态生成类或者增强既有类的功能
- ASM可以直接产生二进制class文件，也可以在类被加载入虚拟机之前动态改变类行为，ASM从类文件中读入信息后，能够改变类行为，分析类信息，甚至能根据要求生成新类
- 目前许多框架如 cglib、Hibernate、spring 都直接或间接地使用ASM操作字节码

### ASM编程模型

- Core API：提供了基于事件形式的编程模型。该模型不需要一次性将整个类的结构读取到内存中，因此这种方式更快，需要的内存更少，但这种编程方式难度较大
- Tree API：提供了基于树型的编程模型。该模型需要一次性将一个类的完整结构全部读取到内存中，所以这种方法需要更多的内存，这种编程方式较简单

### ASM的Core API

- ASM Core ApI 中操纵字节码的功能基于 ClassVisitor 接口。这个接口中的每个方法对应了 class 文件中的每一项
- ASM 提供了三个基于 ClassVisitor 接口的类来实现 class 文件的生成和转换
  - ClassReader：ClassReader 解析一个类的 class 字节码
  - ClassAdapter：ClassAdapter 是 ClassVisitor 的实现类，实现要变化的功能
  - ClassWriter：ClassWriter 也是 ClassVisitro 的实现类，可以用来输出变化后的字节码

- ASM 给我们提供了 ASMifier 工具来帮助开发，可使用ASMifier 工具生成 ASM 结构来对比

# 类加载、连接和初始化

## 类加载和类加载器

- 类被加载到 JVM 开始，到卸载出内存，整个生命周期如图

![20210124162632767](/Users/zhichaozhang/Study/Java/note/JVM/20210124162632767.png)

- 加载：查找并加载类文件的二进制数据
- 连接：就是将已经读入内存的类的二进制数据合并到 JVM 运行时环境中去，包含以下步骤：
  - 验证：确保被加载类的正确性
  - 准备：为类的 静态变量 分配内存，并初始化
  - 解析：把常量池中的符号引用转换成直接引用
- 初始化：为类的静态变量赋初始值

### 类加载要完成的功能

- 通过类的全限定名来获取该类的二进制字节流
- 把二进制字节流转化为方法区的运行时数据结构
- 在堆上创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构，并向外提供了访问方法区内数据结构的接口

### 加载类的方式

- 最常见的方式：本地文件系统中加载、从jar等归档文件中加载
- 动态的方式：将 java 源文件动态编译成 class
- 其他方式：网络下载、从专有数据库中加载等等



### 类加载器

- Java 虚拟机自带的加载器包括以下几种：
  - 启动类加载器（BootstrapClassLoader）
  - 平台类加载器（PlatformClassLoader） JDK8：扩展类加载器（ExtensionClassLoader）
  - 应用程序类加载器（AppClassLoader）
- 用户自定义的加载器：是 java.lang.ClassLoader 的子类，用户可以定制类的加载方式；只不过自定义类加载器其加载的顺序是在所有系统类加载器的最后

### 类加载器的关系

![20210124162714796](/Users/zhichaozhang/Study/Java/note/JVM/20210124162714796.png)

## 类加载器使用

###类加载器说明

- 启动类加载器：用于加载启动的基础模块类，比如：java.base、java.management、java.xml等
- 平台类加载器：用于加载一些平台相关的模块，比如：java.scripting、java.compiler *、java.corba *等
- 应用程序类加载器：用于加载应用级别的模块，比如：jak.compiler、jdk.jartool、jdk.jshell 等等；还加载 classpath 路径中的所有类库
- JDK8：启动类加载器：负责将<JAVA_HOME>/lib，或者 -Xbootclasspath 参数指定的路径中的，且是虚拟机识别的类库加载到内存中（按照名字识别，比如 rt.jar，对于不能识别的文件不予装载）
- JDK8：扩展类加载器：负责加载 <JRE_HOME>/lib/ext，或者 java.ext.dirs 系统变量所指定路径中的所有类库
- JDK8：应用程序类加载器：负责加载 classpath 路径中的所有类库
- Java 程序不能直接引用启动类加载器，直接设置 classLoader 为 null，默认就使用启动类加载器
- 类加载器并不需要等到某个类“首次主动使用”的时候才加载它，JVM规范允许类加载器在预料到某个类将要被使用的时候就预先加载它
- 如果在加载的时候 .class 文件缺失，会在该类首次主动使用时报告 LinkageError 错误，如果一直没有被使用，就不会报错
  

## 双亲委派模型

- JVM中的 ClassLoader 通常采用双亲委派模型，要求除了启动类加载器外，其余的类加载器都应该有自己的父级加载器。这里的父子关系是组合而不是继承，工作过程如下：
  1. 一个类加载器接收到类加载请求后，首先搜索它的内建加载器定义的所有“具名模块”
  2. 如果找到了合适的模块定义，将会使用该加载器来加载
  3. 如果 class 没有在这些加载器定义的具名模块中找到，那么将委托给父级加载器，直到启动类加载器
  4. 如果父级加载器反馈它不能完成加载请求，比如在它的搜索路径下找不到这个类，那子类加载器才自己来加载
  5. 在类路径下找到的类将成为这些加载器的无名模块
- 双亲委派模型对于保证 Java 程序的稳定运作很重要，可以避免一个类被加载多次
- 实现双亲委派的代码在 java.lang.ClassLoader 的 loadClass() 方法中，如果自定义类加载器的话，推荐覆盖实现 findClass() 方法
- 如果有一个类加载器能加载某个类，称为 定义类加载器，所有能成功返回该类的 Class 的类加载器 都被称为初始类加载器

### 双亲委派模型的说明

- 双亲委派模型对于保证 Java 程序的稳定运作很重要
- 实现双亲委派的代码 java.lang.ClassLoader 的 loadClass() 方法中，如果自定义类加载器的话，推荐覆盖实现 findClass() 方法
- 如果有一个类加载器能加载某个类，称为 定义类加载器，所有能成功返回该类的 Class 的类加载器 都被称为 初始化加载器
- 如果没有指定父加载器，默认就是启动类加载器
- 每个类加载器都有自己的命名空间，命名空间由该类加载器及其所有父加载器所加载的类构成，不同的命名空间，可以出现类的全路径名相同的情况
- 运行时包由同一个类加载器的类构成，决定两个类是否属于同一个运行时包，不仅要看全路径名是否一样，还要看定义类加载器是否相同。只有属于同一个运行时包的类才能实现相互包内可见

————————————————
版权声明：本文为CSDN博主「宇 酱」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_46153765/article/details/113092445